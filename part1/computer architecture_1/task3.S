/*
 * Программа ввода кодов цифровых символов в буфер и вывода сообщений в стандартный вывод.
 */

.include "my-macro"

.bss
    .lcomm buf, 100 # буфер для хранения прочитанных символов. Размер - 100 байт
    .lcomm c, 1	# буфер для чтения текущего символа. Размер - 1 байт
    .lcomm s,10	
.text
.global _start

_start:
    sub	%esi, %esi     # указатель адреса байта в буфере символов (индексный регистр)  
    movb $10,s    

show_prompt:
    Puts "Вводите цифру, друг мой!" 	# макровызов вывода строки на стандартный
					# вывод (подсказка ввода)

kbd_input:
    Getchar $c          # макровызов ввода символа со стандартного ввода
    
    cmpl $0, %eax 	# Конец файл - EOF (введено 0 символов) ? 
    je stop		# Да - на завершение программы
    
    cmpb $'\n', c 	# это символ перевода строки ?
    je T1
    cmpb $'9', c  	# код больше кода символа '9' ?
    ja print_err_msg	# ДА - на вывод сообщения об ошибке
    cmpb $'0', c	# код меньше кода символа '0' ?
    jb print_err_msg	# ДА - на вывод сообщения об ошибке
    cmp s,%esi
    je buff_end

    movb c, %al         # код из с пишем в al
    movb %al, buf(%esi) # Загрузить содержимое al (введенный символ) в байт по
			# адресу buf + esi (буфер для вводимых символов)
    incl %esi		# указать на следующий адрес буфера для следующего символа

    Puts "Цифра! Хорошо." # вывод сообщения об успешном вводе
    
    jmp show_prompt	# на ввод следующего символа

print_err_msg:
    Puts "Не цифровая клавиша. Повторите ввод"	# вывод сообщения об ошибке
    jmp show_prompt 	# на ввод следующего символа
buff_end:
	Puts "Нету места"
	jmp stop

T1:
	cmp $0, %esi #
	je kbd_input #если esi равно 0 переходим на метку kbd_input
	decl %esi # уменьшаем esi на 1 
	movb buf(%esi),%bl #  записываем значение из буфера (buf+%esi) в ebx
	sub $48,%ebx # вычитаем из ebx 48
	mov %ebx,%eax # записываем в eax ebx
	incl %esi # увеличиваем на 1
	jmp kbd_input # переходим на метку kbd_input

stop:
    Exit $0
    
.end
